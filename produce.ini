[]
prelude =
 import os

 collections = (
     'hour',
     'dev',

     'ublog-2015_for-yasi_2ndweek',
     'ublog-2015_for-yasi_3rdweek',

     # '2017',
     '2017-02-14',
     '2017-02-20',
 )

 collection_clusters = {
     'dev': '2015-04-04.through.2014-04-10_EN.cfg',
     'hour': '2015-04-04.through.2014-04-10_EN.cfg',

     'ublog-2015_for-yasi_1stweek': '2015-04-04.through.2014-04-10_EN.cfg',
     'ublog-2015_for-yasi_2ndweek': '2015-04-04.through.2014-04-10_EN.cfg',
     'ublog-2015_for-yasi_3rdweek': '2015-04-04.through.2014-04-10_EN.cfg',

     '2017': '2015-04-04.through.2014-04-10_EN.cfg',
     '2017-02-14': '2015-04-04.through.2014-04-10_EN.cfg',
     '2017-02-20': '2015-04-04.through.2014-04-10_EN.cfg',

     'brexit' : '2015-04-04.through.2014-04-10_EN.cfg',
 }

 psql = 'psql -v ON_ERROR_STOP=1 -X -d twitter'

[.db.initialized]
recipe =
       bin/flock initdb &&
       touch %{target}

[tweets/db/%{collection}/%{name}.inserted]
dep.db = .db.initialized
dep.hydrate = tweets/hydrate/%{collection}/%{name}
dep.clusters = %{'clusters/{}'.format(collection_clusters[collection])}
recipe =
    [ ! -d tweets/db/%{collection}/ ] && mkdir tweets/db/%{collection}/

    zcat %{hydrate} \
    |\
    bin/flock -v debug insert \
    --collection=%{collection} \
    --clusters %{clusters} \
    --extract-retweets \
    %{'--language en' if not collection.startswith('lv') else '' }\
    && touch %{target}

[.tweets_%{collection}.inserted]
deps =
     %{'tweets/db/{c}/{n}.inserted'.format(c=collection, n=n) for n in sorted(os.listdir('tweets/hydrate/{}'.format(collection)))}
recipe =
       touch %{target}

[views/.filtered_tweets.created]
dep.db = .db.initialized
dep.view_definition = views/filtered_tweets.sql
dep.ratio = views/.user_mention_screen_name_ratio.created
recipe =
       echo drop materialized view if exists filtered_tweets cascade | %{psql}
       %{psql} < %{view_definition} &&
       touch %{target}

[views/.filtered_feature_counts.created]
dep.db = .db.initialized
dep.filtered_tweets = views/.filtered_tweets.created
dep.view_definition = views/filtered_feature_counts.sql
recipe =
       echo drop materialized view if exists filtered_feature_counts cascade | %{psql}
       %{psql} < %{view_definition} &&
       touch %{target}

[views/.feature_scores.created]
dep.db = .db.initialized
dep.filtered_feature_counts = views/.filtered_feature_counts.created
dep.feature_counts = views/.feature_counts.created
dep.view_definition = views/feature_scores.sql
recipe =
       echo drop materialized view if exists feature_scores cascade | %{psql}
       %{psql} < %{view_definition} &&
       touch %{target}

[views/.%{view}.created]
dep.db = .db.initialized
dep.view_definition = views/%{view}.sql
recipe =
       echo drop materialized view if exists %{view} cascade | %{psql}
       %{psql} < %{view_definition} &&
       touch %{target}

[views/.filtered_tweets.refreshed]
dep.view_created = views/.filtered_tweets.created
dep.ratio = views/.user_mention_screen_name_ratio.refreshed
deps = %{'.tweets_{collection}.inserted'.format(collection=collection) for collection in collections}
recipe =
       echo refresh materialized view filtered_tweets | %{psql} &&
       touch %{target}

[views/.filtered_feature_counts.refreshed]
dep.view_created = views/.filtered_feature_counts.created
dep.filtered_tweets = views/.filtered_tweets.refreshed
deps = %{'.tweets_{collection}.inserted'.format(collection=collection) for collection in collections}
recipe =
       echo refresh materialized view filtered_feature_counts | %{psql} &&
       touch %{target}

[views/.feature_scores.refreshed]
dep.view_created = views/.feature_scores.created
dep.filtered_feature_counts = views/.filtered_feature_counts.refreshed
dep.feature_counts = views/.feature_counts.refreshed
deps = %{'.tweets_{collection}.inserted'.format(collection=collection) for collection in collections}
recipe =
       echo refresh materialized view feature_scores | %{psql} &&
       touch %{target}

[views/.%{view}.refreshed]
dep.view_created = views/.%{view}.created
deps = %{'.tweets_{collection}.inserted'.format(collection=collection) for collection in collections}
recipe =
       echo refresh materialized view %{view} | %{psql} &&
       touch %{target}

[.near_matches_%{collection}.found]
dep.tweets = .tweets_%{collection}.inserted
recipe =
       echo delete from relation where collection = \'%{collection}\' | %{psql} &&
       bin/flock find_near_matches --collection %{collection} &&
       touch %{target}

[.stories_%{collection}.inserted]
dep.tweets = .tweets_%{collection}.inserted
dep.story = stories/%{collection}.json
recipe =
       echo delete from tweet_story where collection = \'%{collection}\' | %{psql} &&
       echo delete from story where collection = \'%{collection}\' | %{psql} &&
       bin/flock insert_stories --collection %{collection} %{story} &&
       touch %{target}

[universe]
type = task
deps =
     %{'.stories_{collection}.inserted'.format(collection=collection) for collection in collections}
     #%{'.near_matches_{collection}.found'.format(collection=collection) for collection in collections}
     #views/.tweet_representative.refreshed
     ##views/.filtered_tweets.refreshed
     ##views/.feature_counts.refreshed
     ##views/.filtered_feature_counts.refreshed
     views/.feature_scores.refreshed

[vacuum]
deps =
     universe
type = task
recipe =
       echo vacuum analyze verbose | %{psql}

[initdb]
type = task
deps =
     .db.initialized

[dropdb]
type = task
recipe =
       bin/flock dropdb
       [ -e .db.initialized ] && rm .db.initialized
